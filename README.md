# microseconds | MCU通用微秒计时函数框架

在嵌入式软件开发里，计时可以说是非常基础的功能模块了，其应用也非常广泛，比如可以辅助计算信号脉冲宽度时间，也可以直接用于常规延时等。相信很多人初次领略 MCU 的神奇都是从计时功能相关小程序开始的。  

在 MCU 里要想实现精确计时，往往都是利用其内部硬件定时器。不同厂商的 MCU，其定时器设计与使用都不太一样。即使是同一 MCU 内，通常也会有好几种不同类型的定时器共存。基于此，笔者设计了一种非常简单实用的通用计时函数框架，这个框架的目的是统一计时函数接口，并且在实现上将通用部分和硬件相关部分剥离开，这样你的嵌入式项目在使用这个框架时可以无缝快捷地切换底层定时器。  

注：本框架主要适合定时器时钟源不小于 1MHz 的 MCU，因为函数接口里延时最小单元是 1us。对于一些定时器时钟源低于 1MHz 的 MCU，可将本框架简单改成成毫秒(milliseconds)计时函数。  

### 一、微秒(microseconds)计时函数库设计
#### 1.1 函数接口定义
首先是设计通用计时函数框架头文件：microseconds.h ，这个头文件里直接定义如下 7 个接口函数原型。涵盖必备的初始化流程init()、shutdown()，最核心的计时功能get_ticks()、convert_to_microseconds()，常用的延时功能delay()、set_delay()、is_timeout()。  

#### 1.2 通用函数实现
然后是设计通用计时函数框架共用源文件：microseconds_common.c，这个文件里涉及三个静态全局变量定义，四个私有函数声明，以及除了 get_ticks() 之外的 6 个接口函数实现。  

其中 s_tickPerMicrosecond 变量存的是每微秒对应计数值，其实这个变量不是一定要定义的，可以在函数需要时实时计算，但为了小小提升框架性能，就在 init() 里将这个值先算出来了，方便其他函数直接使用。  

s_highCounter 变量存的是定时器中断次数，即高位计数器，因为框架 get_ticks() 接口返回的是 64bit 的计数值，对于有些宽度小于 32bit 的定时器，我们常常需要开启定时器中断，否则无法保证系统长时间运行线性计时的正确性（比如 100MHz 时钟源的 32bit 定时器，最长约 43 秒就会清零翻转一次，需要 s_highCounter 变量记录翻转次数）。当然如果 MCU 里能级连出 64bit 的定时器，就可以不用开启中断（清零翻转的时间特别长，可近似认为是永久），s_highCounter 此时就不需要了。  

关于延时函数接口，delay() 用于阻塞型延时，即调用这个函数后一定是死等指定时间后才退出，系统会被强制挂起；set_delay()/is_timeout()用于非阻塞型延时，系统可以继续干其他任务，在需要的时侯来查看一下超时时间是否到了即可。两种延时各有各的用途。  

### 二、微秒(microseconds)计时函数库实现
#### 2.1 定时器相关实现（基于Cortex-M内核的SysTick）
最后是设计 MCU 相关的通用计时函数框架源文件：microseconds_xxTimer.c，这里我们以 Cortex-M 系列 MCU 的内核定时器 SysTick 为例。  

SysTick 是 24bit 递减定时器，时钟源有两种配置：一是内核主频，二是外部时钟（看厂商实现），最常用的时钟源配置就是与内核同频。  

上一节说了用 SysTick 这类宽度小于 32bit 的定时器，是需要开启定时器中断的，所以 s_highCounter 会生效。get_ticks()是整个计时函数框架里最基础也最核心的功能接口，这里面的实现有一个需要特别注意的地方，就是取系统当前计数值可能会有数值回退的风险，需要使用代码中 do {} while()；方式来确保正确性。  

当然还有很多具体 MCU 平台的各种定时器实现，因此这个项目会不断更新，也欢迎大家来参与贡献。  
